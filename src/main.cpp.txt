#include <Util/Path.h>
#include <glad/gl.h>
#include <3DExtensions/VertexBuffer3D.h>
#include <SFML/Window.hpp>
#include <SFML/Graphics.hpp>
#include <chrono>
#include <vector>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <iostream>

void GLAPIENTRY MessageCallback(GLenum source, GLenum type, GLuint id, GLenum severity,
                                 GLsizei length, const GLchar* message, const void* userParam) {
    std::cerr << "GL CALLBACK: " << (type == GL_DEBUG_TYPE_ERROR ? "** GL ERROR **" : "")
              << " Type: " << type << ", Severity: " << severity << ", Message: " << message << std::endl;
}

int main()
{
    auto t_start = std::chrono::high_resolution_clock::now();

    sf::ContextSettings settings;
    settings.depthBits = 24;
    settings.stencilBits = 8;
    settings.majorVersion = 4;
    settings.minorVersion = 6;
    settings.attributeFlags = sf::ContextSettings::Attribute::Debug;

    sf::Window window(sf::VideoMode(800, 600), "Cubes", sf::Style::Titlebar | sf::Style::Close, settings);

    gladLoadGL(sf::Context::getFunction);

    glEnable(GL_DEBUG_OUTPUT);
    glDebugMessageCallback(MessageCallback, 0);

    // Load shaders
    sf::Shader shader;
    if (!shader.loadFromFile(Util::getExecutablePath() / "shaders/cube.vert", Util::getExecutablePath() / "shaders/cube.geo", Util::getExecutablePath() / "shaders/cube.frag")) {
        return -1; // Handle shader loading error
    }

    // Create VertexBuffer3D
    VertexBuffer3D vertexBuffer(sf::PrimitiveType::Points, VertexBuffer3D::Usage::Static);

    // Define vertices
    std::vector<Vertex3D> vertices = {
        {{-0.45f,  0.45f, -0.45f}, {0.0f, 0.0f}},
        {{ 0.45f,  0.45f, -0.45f}, {1.0f, 0.0f}},
        {{ 0.45f, -0.45f, -0.45f}, {1.0f, 1.0f}},
        {{-0.45f, -0.45f, -0.45f}, {0.0f, 1.0f}},
        {{-0.45f,  0.45f,  0.45f}, {0.0f, 0.0f}},
        {{ 0.45f,  0.45f,  0.45f}, {1.0f, 0.0f}},
        {{ 0.45f, -0.45f,  0.45f}, {1.0f, 1.0f}},
        {{-0.45f, -0.45f,  0.45f}, {0.0f, 1.0f}},
    };

    vertexBuffer.create();
    vertexBuffer.update(vertices);

    // Set up transformation matrices
    glm::mat4 view = glm::lookAt(
        glm::vec3(1.5f, 1.5f, 2.0f),
        glm::vec3(0.0f, 0.0f, 0.0f),
        glm::vec3(0.0f, 0.0f, 1.0f)
    );

    glm::mat4 proj = glm::perspective(glm::radians(45.0f), 800.0f / 600.0f, 1.0f, 10.0f);

    bool running = true;
    while (running)
    {
        sf::Event windowEvent;
        while (window.pollEvent(windowEvent))
        {
            if (windowEvent.type == sf::Event::Closed) {
                running = false;
            }
        }

        // Clear the screen
        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        // Calculate transformation
        auto t_now = std::chrono::high_resolution_clock::now();
        float time = std::chrono::duration_cast<std::chrono::duration<float>>(t_now - t_start).count();

        glm::mat4 model = glm::mat4(1.0f);
        model = glm::rotate(model, 0.25f * time * glm::radians(180.0f), glm::vec3(0.0f, 0.0f, 1.0f));

        // Combine model, view, and projection into a single MVP matrix
        glm::mat4 mvp = proj * view * model;

        // Set shader uniform
        shader.setUniform("ModelViewProjection", sf::Glsl::Mat4(glm::value_ptr(mvp)));

        // Bind and draw
        vertexBuffer.bind();
	sf::Shader::bind(&shader);

glDrawArrays(GL_POINTS, 0, 8);
		window.display();
	}
}

